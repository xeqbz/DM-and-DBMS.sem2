--- Task 1 ---
CREATE TABLE GROUPS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    C_VAL NUMBER DEFAULT 0
);

CREATE TABLE STUDENTS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    GROUP_ID NUMBER
);

--- Task 2 ---
CREATE SEQUENCE SEQ_GROUPS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_STUDENTS START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER TRG_GROUPS_BI
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT SEQ_GROUPS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_STUDENTS_BI
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT SEQ_STUDENTS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_GROUPS_NAME_UNIQUE
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    CNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO CNT FROM GROUPS WHERE NAME = :NEW.NAME AND ID != :NEW.ID;
    IF CNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Название группы должно быть уникальным');
    END IF;
END;
/

--- Task 3 ---
CREATE OR REPLACE TRIGGER TRG_CASCADE_DELETE_STUDENTS
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;
/

--- TasK 4- ---
CREATE TABLE STUDENTS_LOG (
    LOG_ID NUMBER PRIMARY KEY,
    STUDENT_ID NUMBER,
    NAME VARCHAR2(100),
    GROUP_ID NUMBER,
    OLD_NAME VARCHAR2(100),
    OLD_GROUP_ID NUMBER,
    ACTION_TYPE VARCHAR2(10),
    LOG_DATE TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE SEQUENCE SEQ_STUDENTS_LOG START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER TRG_STUDENTS_LOG
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO STUDENTS_LOG (LOG_ID, STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, LOG_DATE)
        VALUES (STUDENTS_LOG_SEQ.NEXTVAL, :NEW.ID, :NEW.NAME, :NEW.GROUP_ID,
                'INSERT', SYSTIMESTAMP);
    ELSIF UPDATING THEN
        INSERT INTO STUDENTS_LOG (LOG_ID, STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, LOG_DATE, OLD_NAME, OLD_GROUP_ID)
        VALUES (STUDENTS_LOG_SEQ.NEXTVAL, :NEW.ID, :NEW.NAME, :NEW.GROUP_ID, 'UPDATE',
                SYSTIMESTAMP, :OLD.NAME, :OLD.GROUP_ID);
    ELSIF DELETING THEN
        INSERT INTO STUDENTS_LOG (LOG_ID, STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, LOG_DATE, OLD_NAME, OLD_GROUP_ID)
        VALUES (STUDENTS_LOG_SEQ.NEXTVAL, :OLD.ID, :OLD.NAME, :OLD.GROUP_ID, 'DELETE',
                SYSTIMESTAMP, :OLD.NAME, :OLD.GROUP_ID);
    END IF;
END;
/

--- Task 5 ---
CREATE OR REPLACE PROCEDURE RESTORE_STUDENTS_TO_TIMESTAMP (P_TIME TIMESTAMP) AS
BEGIN
    INSERT INTO STUDENTS (ID, NAME, GROUP_ID)
    SELECT SLOG.STUDENT_ID, SLOG.OLD_NAME, SLOG.OLD_GROUP_ID
    FROM STUDENTS_LOG SLOG
    WHERE SLOG.ACTION_TYPE = 'DELETE'
    AND SLOG.LOG_DATE <= P_TIME
    AND NOT EXISTS(SELECT 1 FROM STUDENTS WHERE ID = SLOG.STUDENT_ID);

    UPDATE STUDENTS S
    SET (S.NAME, S.GROUP_ID) = (
        SELECT SLOG.OLD_NAME, SLOG.OLD_GROUP_ID
        FROM STUDENTS_LOG SLOG
        WHERE SLOG.STUDENT_ID = S.ID
        AND SLOG.ACTION_TYPE = 'UPDATE'
        AND SLOG.LOG_DATE <= P_TIME
        ORDER BY SLOG.LOG_DATE DESC
        FETCH FIRST 1 ROWS ONLY
    )
    WHERE EXISTS (
        SELECT 1
        FROM STUDENTS_LOG SLOG
        WHERE SLOG.STUDENT_ID = S.ID
        AND SLOG.ACTION_TYPE = 'UPDATE'
    );

    DELETE FROM STUDENTS S
    WHERE EXISTS (
        SELECT 1
        FROM STUDENTS_LOG SLOG
        WHERE SLOG.STUDENT_ID = S.ID
        AND SLOG.ACTION_TYPE = 'INSERT'
        AND SLOG.LOG_DATE > P_TIME
    );

    DBMS_OUTPUT.PUT_LINE('Students restored to the state at ' || P_TIME);
END;
/

--- Task 6 ---
CREATE OR REPLACE TRIGGER TRG_UPDATE_GROUP_COUNT
AFTER INSERT OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
    ELSIF DELETING THEN
        UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
    END IF;
END;
/